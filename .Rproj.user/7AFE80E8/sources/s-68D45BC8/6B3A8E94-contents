#This is an example on how to process data with FOSTER package

#Loading Foster functions
source('Y:/Martin_Queinnec/Foster/Martin Scripts/calcIndices.R')
source('Y:/Martin_Queinnec/Foster/Martin Scripts/temporalMetrics.R')
source('Y:/Martin_Queinnec/Foster/Martin Scripts/utils.R')
source('Y:/Martin_Queinnec/Foster/Martin Scripts/Sample.R')
source('Y:/Martin_Queinnec/Foster/Martin Scripts/MatchExtent.R')
source('Y:/Martin_Queinnec/Foster/Martin Scripts/MatchResolution.R')


sourceComposite <- "Y:/Martin_Queinnec/BC_Wildfires/AFRF_NTEMS/mosaicked/proxy_values/"
sourceMetrics <- "Z:/Kamloops_LiDAR/kamloops/"

metrics <- brick(list(paste0(sourceMetrics,"BA4.tif"),paste0(sourceMetrics,"HT_lorey4.tif"),paste0(sourceMetrics,"V_wsv4.tif")))

# Match resolution and extent of composite raster and metrics 
ind <- brick(paste0(sourceComposite,"Mosaic_SRef_UTM10S_1984_proxy_v2.dat"))

to_crs <- crs(ind)
metrics_proj <- projectRaster(metrics,crs=to_crs)

ind_crop <- crop(ind,extent(metrics_proj))

#Match resolution 
metrics_resampled <- resample(metrics_proj,ind_crop)


years <- seq(1984,1986,1)

indices <- list()

for (y in 1:length(years)) {
  file <- paste0(sourceComposite,"Mosaic_SRef_UTM10S_",years[y],"_proxy_v2.dat")
  r <- brick(file)
  r_crop <- raster::crop(r,extent(metrics_resampled))
  r_mask <- raster::mask(r_crop,metrics_resampled) #Calculate indices only where we have ALS metrics
  #r_mask <- raster::crop(r,extent(450000,451000,5500000,5501000)) #Crop input for faster example
  indices[[y]] <- calcIndices(r_mask,method = "ndvi",writeToFile = FALSE,red=3,nir=4) ## Using calcIndices() from Foster
}

#If we calculate indices like NDVI, we have signle band outputs that we can directly stack/brick together
#If we calculate TC indices, we have 3 band outputs. We need to separate each band before stacking/bricking them together

timeSeries <- brick(indices)

timeMetrics <- TemporalMetrics(timeSeries,output_dir = ".")


#Create stratified random sample of points based on BA, lor and Vol
sampleLoc <- getSampleXY(metrics_resampled,n=100,mindist = 500)

#Divide sample locations in training and testing sets
trainingSet <- dplyr::sample_frac(sampleLoc@data,0.75)
testingSet <- dplyr::setdiff(sampleLoc@data,trainingSet)

sampleValues_variables <- GetSampleValues(metrics_resampled,sampleLoc)
sampleValues_predictors <- GetSampleValues(timeMetrics,sampleLoc)



