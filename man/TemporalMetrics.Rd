% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/TemporalMetrics.R
\name{temporalMetrics}
\alias{temporalMetrics}
\title{Calculate temporal metrics}
\usage{
temporalMetrics(s, metrics = "defaultTemporalSummary", prefix = NULL,
  filename = "", par = F, no_cores = 1, m = 2, ...)
}
\arguments{
\item{metrics}{Name of a function  used to process the time series.}

\item{prefix}{Optional. Charatcer that will be added to the names of the output}

\item{filename}{Filenmae if output written to disk}

\item{par}{Logical indication if the processigng shoudl be done on multiple cores}

\item{no_cores}{Number of cores to use. Only relevant if par=TRUE}

\item{m}{tuning parameter to determine how many blocks will be used (m blocks will be procesed by each cluster)}

\item{...}{Other arguments passed to \code{\link[raster]{writeRaster}}}

\item{x}{Input Raster or SpatialPointsDataFrame object containing a time series of spectral indices (e.g. NDVI). Input stack may be generated with \code{calcIndices}}
}
\description{
This function calculates a set of user-defined or default statistics from a time series of variables. If \code{s} is a Raster object, each layer should be a year of the time series. If \code{s} is a SpatialPointsDataFrame object, each column should be a year of the time series.The argument \code{fun} defines which metrics will be calculated. It has to be the name of a function that takes a vector as input and returns a named vector corresponding to the summary metrics. The function \code{defaultTemporalSummary} is used by default and returns the mean, standard deviation, median, IQR and Theil-Sen slope of the time series.
}
\details{
If \code{s} is a Raster object, the processing can be parallelized using \code{\link[raster]{clusterR}}. In that case the user has to set \code{par=TRUE} and provide the number of cores \code{no-cores}.
}
\examples{
#Create function that calculates mean and standard deviation and use it with temporalMetrics
myfunction <- function(x) c(mean=mean(x,na.rm=T),sd=sd(x,na.rm=T))
temporalMetrics(x,fun="myfunction")
}
